# -*- coding: utf-8 -*-
"""License_Plate_Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1194up1wvdb9nyD3Gf2auq4lYZBrK-9Hy

# **License Plate Detection Project Using YOLO**
"""

!pip install ultralytics

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
  
!kaggle datasets download -d andrewmvd/car-plate-detection

!unzip /content/car-plate-detection.zip

import os
import shutil # for move the file
import re
import xml.etree.ElementTree as xet # for xml annotations
import pandas as pd
import cv2 # computer vision
import matplotlib.pyplot as plt
import random
from sklearn.model_selection import train_test_split

os.makedirs("License_Plate_Detector",exist_ok=True) # make the folder

shutil.move("annotations","License_Plate_Detector/annotations") # move annotation folder to our folder that is license plate detector
shutil.move("images",'License_Plate_Detector/images') # move images folder to our folder that is license plate detector

dataset_path = '/content/License_Plate_Detector' # base dir path

def extract_number(filename):
  """
  This function will returns the value that is in the image name

  ex: file name : img123  -> this function will return 123
  ex: file name : img  -> this function will return 0
  """
  match = re.search(r'(\d+)',filename) # scearch the digit in the image name
  if match:
    return int(match.group(0)) # return the all the digit
  else:
    return 0

labels_dict = dict(
    img_path = [],
    xmin = [],
    xmax = [],
    ymin = [],
    ymax = [],
    img_w = [],
    img_h = []
) # make dict that contanis info about the image

def get_annotation(xml_file, img_dir=f"{dataset_path}/images/"):
  """
  This function will give the annotation of the image with the label and store it in the labels_dict

  In the labels_dict we have the following keys:
  - img_path: path to the image
  - xmin: x-coordinate of the top-left corner of the bounding box
  - xmax: x-coordinate of the bottom-right corner of the bounding box
  - ymin: y-coordinate of the top-left corner of the bounding box
  - ymax: y-coordinate of the bottom-right corner of the bounding box
  - img_w: width of the image
  - img_h: height of the image

  """
  info = xet.parse(xml_file) # Parse the XML file and load its content into an ElementTree object
  root = info.getroot() # get root from the info object

  filename = root.find("filename").text  # Find the first 'filename' element under the root and extract its text content
  img_path = os.path.join(img_dir, filename) # Join the image directory path with the extracted filename

  width = int(root.find("size/width").text) # Find the width from the size element and store it
  height = int(root.find("size/height").text) # Find the height from the size element and store it

  for obj in root.findall("object"): # the for loop will find remaining annotation
    bbox = obj.find("bndbox") # bounding box
    xmin = int(bbox.find("xmin").text) # x minimum
    ymin = int(bbox.find("ymin").text) # y minimum
    xmax = int(bbox.find("xmax").text) # x maximum
    ymax = int(bbox.find("ymax").text) # y maximum

    # append all the annotation in the labels_dict
    labels_dict["img_path"].append(img_path)
    labels_dict["xmin"].append(xmin)
    labels_dict["ymin"].append(ymin)
    labels_dict["xmax"].append(xmax)
    labels_dict["ymax"].append(ymax)
    labels_dict["img_w"].append(width)
    labels_dict["img_h"].append(height)

    return labels_dict

annotations_folder = f"{dataset_path}/annotations/"
for xml_file in os.listdir(annotations_folder): # this for loop will going through all the file in the annotation folder
    if xml_file.endswith(".xml"): # if file extention is .xml then the get_annotation functions will apply on that perticuler file
        get_annotation(os.path.join(annotations_folder, xml_file))

alldata = pd.DataFrame(labels_dict) # convert labels_dict into dataframe

alldata

train,test = train_test_split(alldata,test_size=0.1,random_state=42) # split in train and test

train,val = train_test_split(train,train_size = 8/9,random_state=42) # split in train and validation

def split_folder_in_yolo_formate(split_name, split_df):

  """
  This function creates folders for images and labels in YOLO format for a given data split
  (train, validation, or test) and converts bounding box annotations from Pascal VOC format
  (xmin, ymin, xmax, ymax) to YOLO format (class_id x_center y_center width height).
  It then saves the YOLO formatted annotations to .txt files and copies the corresponding images.
  """

  labels_path = os.path.join('datasets','cars_license_plate_new',split_name,'labels') # make path for the labels
  images_path = os.path.join('datasets','cars_license_plate_new',split_name,'images') # make path for the images

  # make the directory using path
  os.makedirs(labels_path,exist_ok=True)
  os.makedirs(images_path,exist_ok=True)

  for _, row in split_df.iterrows(): # Iterate through each row of the DataFrame 'split_df'
    img_name,img_extention = os.path.splitext(os.path.basename(row['img_path'])) # Extract the filename and its extension from the 'img_path' column of the current row

    x_center = (row['xmin']+row['xmax'])/2 /row['img_w'] # Calculate the x-coordinate of the bounding box center
    y_center = (row['ymin'] + row['ymax'])/2 / row['img_h'] # Calculate the y-coordinate of the bounding box center
    width = ((row['xmax'])- row['xmin']) / row['img_w'] # Calculate the width of the bounding box
    height = (row['ymax'] - row['ymin'])  /row['img_h'] # Calculate the height of the bounding box

    label_path = os.path.join(labels_path,f'{img_name}.txt') # Construct the full path for the YOLO label file
    with open(label_path,'w') as f: # open the label path in write mode
      f.write(f'0 {x_center:.4f} {y_center:.4f} {width:.4f} {height:.4f}') # Write the bounding box information to the text file

    shutil.copy(row['img_path'],os.path.join(images_path,img_name+img_extention)) # Copy the original image file
  print(f"Created '{images_path} and '{labels_path}") # confirmation message

split_folder_in_yolo_formate('train',train) # apply function on the train data
split_folder_in_yolo_formate('val',val) # apply function on the validation data
split_folder_in_yolo_formate('test',test) # apply function on the test data

images_dir = '/content/datasets/cars_license_plate_new/train/images'
label_dir = '/content/datasets/cars_license_plate_new/train/labels'

image_file = sorted(os.listdir(images_dir)) # list of image filenames sorted alphabetically

def show_yolo_images(images_dir, labels_dir, image_files, max_images=5):
  """
  This function will show the images with the bounding boxes.
  """
  for i, img_file in enumerate(image_files[:max_images]): # Loop through a specified number of image files
    image_path = os.path.join(images_dir, img_file) # Create the full path for the image file by joining the images directory
    label_path = os.path.join(labels_dir, os.path.splitext(img_file)[0] + '.txt') # Create the full path for the corresponding label file

    image = cv2.imread(image_path) # Read the image file from the specified path using OpenCV
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # Convert the image's color space from BGR to RGB

    if os.path.exists(label_path): # Check if the label file for the current image exists
      with open(label_path, 'r') as f: # Open the label file in 'read' mode
        lines = f.readlines() # read all the lines

      for line in lines: # Loop through each line read from the label file
        class_id, x_center, y_center, width, height = map(float, line.strip().split()) # xtract the object's bounding box information
        img_height, img_width, _ = image.shape # Get the shape of the image

        x_center *= img_width # Convert the x-center coordinate back to pixel value
        y_center *= img_height # Convert the y-center coordinate back to pixel value
        width *= img_width # Convert the width back to pixel value
        height *= img_height # Convert the normalized height back to pixel value

        x1 = int(x_center - width / 2) # Calculate the x-coordinate of the top-left corner of the bounding box
        y1 = int(y_center - height / 2) # Calculate the y-coordinate of the top-left corner
        x2 = int(x_center + width / 2) # Calculate the x-coordinate of the bottom-right corner
        y2 = int(y_center + height / 2) # Calculate the y-coordinate of the bottom-right corner

        cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2) # Draw the rectangle on the image

    # show the image using matplotlib
    plt.figure(figsize=(5, 5))
    plt.imshow(image)
    plt.axis('off')
    plt.show()

image_files = os.listdir(images_dir)
random.shuffle(image_files) # shuffle for the random output
show_yolo_images(images_dir, label_dir, image_files, max_images=3) # call the function

import yaml

# Define dataset config
data_config = {
    'train': '/content/datasets/cars_license_plate_new/train',
    'val': '/content/datasets/cars_license_plate_new/val',
    'test': '/content/datasets/cars_license_plate_new/test',  # optional
    'nc': 1,  # number of classes
    'names': ['license_plate']  # class names
}

# Save to yaml file
yaml_path = '/content/datasets/license_plate.yaml'
with open(yaml_path, 'w') as f:
    yaml.dump(data_config, f, default_flow_style=False)

print(f"YAML file created at: {yaml_path}")

from ultralytics import YOLO
model = YOLO("yolov8n.pt")
model.train(data="/content/datasets/license_plate.yaml", epochs=50)
model.save("best.pt")

